/***************************** Include Files *********************************/
#include "xgpio.h"


#define EUI48_SIZE					6				/* EUI48 size in Bytes */



/************************** Static Forward Declarations **********************/

static void ow_waitQuarts(u8 quarts);
static void ow_send(u8 bit);
static u8   ow_checkSak(void);
static void ow_dropSak(void);
static u8 ow_readDataBit(void);
static u8 ow_readDataByte(void);


/************************** Global Variable Definitions **********************/

//XEmacLite emacLiteInstance;																		/* Instance of the EmacLite driver */
u8 ow_EUI48[EUI48_LEN];


/************************** Static Eth.c Variable Definitions ****************/

//volatile u8 ow_EUI48[];															/* Indicates the length of the Received packet */


/*****************************************************************************/


/************************** Functions ****************************************/

/* Onewire Delay: one quart equals to 25 us = 2500 cycles */
static void ow_waitQuarts(u8 quarts)
{
	const u16 loopCtr = (u16)quarts * (u16)500U;

	for (u16 loopIdx = loopCtr; loopIdx; --loopIdx)
		;
}

static void ow_send(u8 bit)
{
	switch (bit)
	{
	default:
	case 0:
		XGpio_DiscreteSet(&gpio_OnewireEUI48, 1U, 0x00000001UL);
		ow_waitQuarts(2);
		XGpio_DiscreteClear(&gpio_OnewireEUI48, 1U, 0x00000001UL);
		ow_waitQuarts(2);
		break;

	case 1:
		XGpio_DiscreteClear(&gpio_OnewireEUI48, 1U, 0x00000001UL);
		ow_waitQuarts(2);
		XGpio_DiscreteSet(&gpio_OnewireEUI48, 1U, 0x00000001UL);
		ow_waitQuarts(2);
		break;
	}
}

static u8 ow_checkSak(void)
{
	u8 ow_sak1, ow_sak2;

	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xffffffffUL);  // ow-bit: input
	ow_waitQuarts(1);	/* 25 us */
	ow_sak1 = XGpio_DiscreteRead(&gpio_OnewireEUI48, 1U) & 0x00000001UL;
	ow_waitQuarts(2);	/* 50 us */
	ow_sak2 = XGpio_DiscreteRead(&gpio_OnewireEUI48, 1U) & 0x00000001UL;
	ow_waitQuarts(1);	/* 25 us */

	/* Check SAK response */
	if (ow_sak1 || !ow_sak2) {
		/* No response */
		return 0xffU;
	}

	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xfffffffeUL);  // ow-bit: output
	return 0U;
}

static void ow_dropSak(void)
{
	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xffffffffUL);  // ow-bit: input
	ow_waitQuarts(4);	/* 100 us */
	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xfffffffeUL);  // ow-bit: output
}

static u8 ow_readDataBit(void)
{
	u8 ow_bit1, ow_bit2;

	ow_waitQuarts(1);	/* 25 us */
	ow_bit1 = XGpio_DiscreteRead(&gpio_OnewireEUI48, 1U) & 0x00000001UL;
	ow_waitQuarts(2);	/* 50 us */
	ow_bit2 = XGpio_DiscreteRead(&gpio_OnewireEUI48, 1U) & 0x00000001UL;
	ow_waitQuarts(1);	/* 25 us */

	if (!ow_bit1 && ow_bit2) {
		return 1U;
	} else {
		return 0U;
	}
}

static u8 ow_readDataByte(void)
{
	u8 byte = 0U;

	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xffffffffUL);  // ow-bit: input

	for (u8 idx = 0U; idx < 8U; idx++) {
		byte <<= 1;
		byte |= (ow_readDataBit() ?  1U : 0U);

		if (idx < 7U) {
			/* MAK */
			XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xfffffffeUL);  // ow-bit: output
			ow_send(1U);
			XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xffffffffUL);  // ow-bit: input

		} else {
			/* No-MAK */
			XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xfffffffeUL);  // ow-bit: output
			ow_send(0U);
			XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xffffffffUL);  // ow-bit: input
		}
	}

	if (ow_checkSak()) {
		return 0U;
	}

	return byte;
}

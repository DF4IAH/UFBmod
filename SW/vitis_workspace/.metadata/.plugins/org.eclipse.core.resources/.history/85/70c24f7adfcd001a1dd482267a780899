/***************************** Include Files *********************************/
#include "xgpio.h"


//#define OW_TEST_DELAYLOOP																		/* Initial set-up of delay loop */

#ifdef OW_TEST_DELAYLOOP
#include "FreeRTOS.h"
#include "task.h"
#endif


#define EUI48_SIZE					6															/* EUI48 size in Bytes */


/************************** Static Forward Declarations **********************/

static void ow_waitQuarts(u8 quarts);
static void ow_send(u8 bit);
static u8   ow_checkSak(void);
static void ow_dropSak(void);
static u8 ow_readDataBit(void);
static u8 ow_readDataByte(void);


/************************** Global Variable Definitions **********************/

//XEmacLite emacLiteInstance;																	/* Instance of the EmacLite driver */

u8 owEUI48[EUI48_SIZE];

/************************** Static Eth.c Variable Definitions ****************/

static XGpio gpio_OnewireEUI48;																	/* EUI48 device */

#ifdef OW_TEST_DELAYLOOP
static XGpio ow_gpio_PWM_Lights;																/* Local instance - PWM Lights */
#endif


/*****************************************************************************/


/************************** Functions ****************************************/

/* Onewire Delay: one quart equals to 25 us = 2500 cycles */
static void ow_waitQuarts(u8 quarts)
{
	const u8 loopCtr = quarts * (u8)10U;

	for (u8 loopIdx = loopCtr; loopIdx; --loopIdx)
		;
}

static void ow_send(u8 bit)
{
	switch (bit)
	{
	default:
	case 0:
		XGpio_DiscreteSet(&gpio_OnewireEUI48, 1U, 0x00000001UL);
		ow_waitQuarts(2);
		XGpio_DiscreteClear(&gpio_OnewireEUI48, 1U, 0x00000001UL);
		ow_waitQuarts(2);
		break;

	case 1:
		XGpio_DiscreteClear(&gpio_OnewireEUI48, 1U, 0x00000001UL);
		ow_waitQuarts(2);
		XGpio_DiscreteSet(&gpio_OnewireEUI48, 1U, 0x00000001UL);
		ow_waitQuarts(2);
		break;
	}
}

static void ow_getLevels(volatile u8* left, volatile u8* right)
{
	ow_waitQuarts(1);	/* 25 us */
	*left = XGpio_DiscreteRead(&gpio_OnewireEUI48, 1U) & 0x00000001UL;
	ow_waitQuarts(2);	/* 50 us */
	*right = XGpio_DiscreteRead(&gpio_OnewireEUI48, 1U) & 0x00000001UL;
	ow_waitQuarts(1);	/* 25 us */
}

static u8 ow_checkSak(void)
{
	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xffffffffUL);  // ow-bit: input

	volatile u8 ow_sak1, ow_sak2;
	ow_getLevels(&ow_sak1, &ow_sak2);

	/* Check SAK response */
	if (ow_sak1 || !ow_sak2) {
		/* No response */
		return 0xffU;
	}

	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xfffffffeUL);  // ow-bit: output
	return 0U;
}

static void ow_dropSak(void)
{
	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xffffffffUL);  // ow-bit: input

	ow_waitQuarts(4);	/* 100 us */

	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xfffffffeUL);  // ow-bit: output
}

static u8 ow_readDataBit(void)
{
	volatile u8 ow_bit1, ow_bit2;
	ow_getLevels(&ow_bit1, &ow_bit2);

	if (!ow_bit1 && ow_bit2) {
		return 1U;
	} else {
		return 0U;
	}
}

static u8 ow_readDataByte(void)
{
	u8 byte = 0U;

	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xffffffffUL);  // ow-bit: input

	for (u8 idx = 0U; idx < 8U; idx++) {
		byte <<= 1;
		byte |= (ow_readDataBit() ?  1U : 0U);

		if (idx < 7U) {
			/* MAK */
			XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xfffffffeUL);  // ow-bit: output
			ow_send(1U);
			XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xffffffffUL);  // ow-bit: input

		} else {
			/* No-MAK */
			XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xfffffffeUL);  // ow-bit: output
			ow_send(0U);
			XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0xffffffffUL);  // ow-bit: input
		}
	}

	if (ow_checkSak()) {
		/* Drop data byte */
		return 0U;
	}

	return byte;
}

u8 owreadEUI48(u8 eui48[6])
{
	int statusOnewireEUI48 = XGpio_Initialize(&gpio_OnewireEUI48, XPAR_AXI_ONEWIRE_GPIO_0_DEVICE_ID);
	if (statusOnewireEUI48 != XST_SUCCESS) {
		xil_printf("GPIO Onewire EUI-48 Initialization Failed\r\n");
		return 1U;
	}

	XGpio_SetDataDirection(&gpio_OnewireEUI48, 1U, 0x7fffffffUL);  //  1 bit output (Start), 1 bit input (Running), 14 bit input (DC), 16 bit input (MSB EUI-48)
	XGpio_SetDataDirection(&gpio_OnewireEUI48, 2U, 0xffffffffUL);  // 32 bit input (LSB EUI-48)

	/* Reset EUI48 unit */
	XGpio_DiscreteClear(&gpio_OnewireEUI48, 1U, 0x0000000UL);
	while (1) {
		u32 gpio1 = XGpio_DiscreteRead(&gpio_OnewireEUI48, 1);
		if (gpio1 & 0x40000000UL == 0UL) {
			// Ready for new read out
			break;
		}
	}

	/* Send run */
	XGpio_DiscreteSet(&gpio_OnewireEUI48, 1U, 0x80000000UL);
	while (1) {
		u32 gpio1 = XGpio_DiscreteRead(&gpio_OnewireEUI48, 1);
		if (gpio1 & 0x40000000UL != 0UL) {
			// EUI48 FSM running
			break;
		}
	}

	/* Wait until ready */
	while (1) {
		u32 gpio1 = XGpio_DiscreteRead(&gpio_OnewireEUI48, 1);
		if (gpio1 & 0x40000000UL == 0UL) {
			// Ready for new read out
			break;
		}
	}

	/* Read out */
	{
		u32 gpio1 = XGpio_DiscreteRead(&gpio_OnewireEUI48, 1);
		u32 gpio2 = XGpio_DiscreteRead(&gpio_OnewireEUI48, 2);

		eui48[0] = (u8) (gpio1 >>  8);
		eui48[1] = (u8) (gpio1 >>  0);
		eui48[2] = (u8) (gpio2 >> 24);
		eui48[3] = (u8) (gpio2 >> 16);
		eui48[4] = (u8) (gpio2 >>  8);
		eui48[5] = (u8) (gpio2 >>  0);
	}

	return XST_SUCCESS;
}
